{"ast":null,"code":"import SockJS from 'sockjs-client';\nimport { Stomp } from '@stomp/stompjs';\n\n// WebSocket service for real-time communication\nclass WebSocketService {\n  constructor() {\n    this.stompClient = null;\n    this.connected = false;\n    this.messageHandlers = new Map();\n    this.callHandlers = new Map();\n    this.webRTCHandlers = new Map();\n    this.receiptHandlers = new Map();\n  }\n\n  // Connect to WebSocket\n  connect(onConnect = null, onError = null) {\n    if (this.stompClient) {\n      return;\n    }\n    const socket = new SockJS('/ws');\n    this.stompClient = Stomp.over(function () {\n      return socket;\n    });\n\n    // Disable debug logs\n    this.stompClient.debug = () => {};\n\n    // Connect to STOMP websocket\n    this.stompClient.connect({},\n    // No headers needed for now\n    frame => {\n      this.connected = true;\n      console.log('WebSocket connected');\n      if (onConnect) onConnect(frame);\n    }, error => {\n      console.error('WebSocket connection error:', error);\n      this.connected = false;\n      if (onError) onError(error);\n    });\n  }\n\n  // Disconnect from WebSocket\n  disconnect() {\n    if (this.stompClient && this.connected) {\n      this.stompClient.disconnect();\n      this.stompClient = null;\n      this.connected = false;\n      console.log('WebSocket disconnected');\n    }\n  }\n\n  // Subscribe to user's private message queue\n  subscribeToUserMessages(userId, callback) {\n    if (!this.stompClient || !this.connected) {\n      console.error('WebSocket not connected');\n      return null;\n    }\n    const destination = `/user/${userId}/queue/messages`;\n    const subscription = this.stompClient.subscribe(destination, message => {\n      const messageData = JSON.parse(message.body);\n      callback(messageData);\n    });\n    this.messageHandlers.set(userId, subscription);\n    return subscription;\n  }\n\n  // Subscribe to read receipts\n  subscribeToReadReceipts(userId, callback) {\n    if (!this.stompClient || !this.connected) {\n      console.error('WebSocket not connected');\n      return null;\n    }\n    const destination = `/user/${userId}/queue/receipts`;\n    const subscription = this.stompClient.subscribe(destination, message => {\n      const receiptData = JSON.parse(message.body);\n      callback(receiptData);\n    });\n    this.receiptHandlers.set(userId, subscription);\n    return subscription;\n  }\n\n  // Subscribe to call notifications\n  subscribeToCallNotifications(userId, callback) {\n    if (!this.stompClient || !this.connected) {\n      console.error('WebSocket not connected');\n      return null;\n    }\n    const destination = `/user/${userId}/queue/calls`;\n    const subscription = this.stompClient.subscribe(destination, message => {\n      const callData = JSON.parse(message.body);\n      callback(callData);\n    });\n    this.callHandlers.set(userId, subscription);\n    return subscription;\n  }\n\n  // Subscribe to WebRTC signaling\n  subscribeToWebRTC(userId, callback) {\n    if (!this.stompClient || !this.connected) {\n      console.error('WebSocket not connected');\n      return null;\n    }\n    const destination = `/user/${userId}/queue/webrtc`;\n    const subscription = this.stompClient.subscribe(destination, message => {\n      const signalData = JSON.parse(message.body);\n      callback(signalData);\n    });\n    this.webRTCHandlers.set(userId, subscription);\n    return subscription;\n  }\n\n  // Send a chat message\n  sendMessage(message) {\n    if (!this.stompClient || !this.connected) {\n      console.error('WebSocket not connected');\n      return false;\n    }\n    this.stompClient.send('/app/chat.send', {}, JSON.stringify(message));\n    return true;\n  }\n\n  // Send read receipt for a message\n  sendReadReceipt(receipt) {\n    if (!this.stompClient || !this.connected) {\n      console.error('WebSocket not connected');\n      return false;\n    }\n    this.stompClient.send('/app/chat.read', {}, JSON.stringify(receipt));\n    return true;\n  }\n\n  // Send WebRTC offer signal\n  sendOffer(signal) {\n    if (!this.stompClient || !this.connected) {\n      console.error('WebSocket not connected');\n      return false;\n    }\n    this.stompClient.send('/app/call.offer', {}, JSON.stringify(signal));\n    return true;\n  }\n\n  // Send WebRTC answer signal\n  sendAnswer(signal) {\n    if (!this.stompClient || !this.connected) {\n      console.error('WebSocket not connected');\n      return false;\n    }\n    this.stompClient.send('/app/call.answer', {}, JSON.stringify(signal));\n    return true;\n  }\n\n  // Send ICE candidate\n  sendIceCandidate(signal) {\n    if (!this.stompClient || !this.connected) {\n      console.error('WebSocket not connected');\n      return false;\n    }\n    this.stompClient.send('/app/call.ice', {}, JSON.stringify(signal));\n    return true;\n  }\n\n  // Send hangup signal\n  sendHangup(signal) {\n    if (!this.stompClient || !this.connected) {\n      console.error('WebSocket not connected');\n      return false;\n    }\n    this.stompClient.send('/app/call.hangup', {}, JSON.stringify(signal));\n    return true;\n  }\n\n  // Unsubscribe from all\n  unsubscribeAll() {\n    this.messageHandlers.forEach(subscription => {\n      subscription.unsubscribe();\n    });\n    this.messageHandlers.clear();\n    this.receiptHandlers.forEach(subscription => {\n      subscription.unsubscribe();\n    });\n    this.receiptHandlers.clear();\n    this.callHandlers.forEach(subscription => {\n      subscription.unsubscribe();\n    });\n    this.callHandlers.clear();\n    this.webRTCHandlers.forEach(subscription => {\n      subscription.unsubscribe();\n    });\n    this.webRTCHandlers.clear();\n  }\n}\nexport default new WebSocketService();","map":{"version":3,"names":["SockJS","Stomp","WebSocketService","constructor","stompClient","connected","messageHandlers","Map","callHandlers","webRTCHandlers","receiptHandlers","connect","onConnect","onError","socket","over","debug","frame","console","log","error","disconnect","subscribeToUserMessages","userId","callback","destination","subscription","subscribe","message","messageData","JSON","parse","body","set","subscribeToReadReceipts","receiptData","subscribeToCallNotifications","callData","subscribeToWebRTC","signalData","sendMessage","send","stringify","sendReadReceipt","receipt","sendOffer","signal","sendAnswer","sendIceCandidate","sendHangup","unsubscribeAll","forEach","unsubscribe","clear"],"sources":["/workspaces/java-besic-to-advance/Messanger-App/frontend/src/services/WebSocketService.js"],"sourcesContent":["import SockJS from 'sockjs-client';\nimport { Stomp } from '@stomp/stompjs';\n\n// WebSocket service for real-time communication\nclass WebSocketService {\n  constructor() {\n    this.stompClient = null;\n    this.connected = false;\n    this.messageHandlers = new Map();\n    this.callHandlers = new Map();\n    this.webRTCHandlers = new Map();\n    this.receiptHandlers = new Map();\n  }\n\n  // Connect to WebSocket\n  connect(onConnect = null, onError = null) {\n    if (this.stompClient) {\n      return;\n    }\n\n    const socket = new SockJS('/ws');\n    this.stompClient = Stomp.over(function() {\n      return socket;\n    });\n    \n    // Disable debug logs\n    this.stompClient.debug = () => {};\n\n    // Connect to STOMP websocket\n    this.stompClient.connect(\n      {}, // No headers needed for now\n      frame => {\n        this.connected = true;\n        console.log('WebSocket connected');\n        if (onConnect) onConnect(frame);\n      },\n      error => {\n        console.error('WebSocket connection error:', error);\n        this.connected = false;\n        if (onError) onError(error);\n      }\n    );\n  }\n\n  // Disconnect from WebSocket\n  disconnect() {\n    if (this.stompClient && this.connected) {\n      this.stompClient.disconnect();\n      this.stompClient = null;\n      this.connected = false;\n      console.log('WebSocket disconnected');\n    }\n  }\n\n  // Subscribe to user's private message queue\n  subscribeToUserMessages(userId, callback) {\n    if (!this.stompClient || !this.connected) {\n      console.error('WebSocket not connected');\n      return null;\n    }\n\n    const destination = `/user/${userId}/queue/messages`;\n    const subscription = this.stompClient.subscribe(destination, (message) => {\n      const messageData = JSON.parse(message.body);\n      callback(messageData);\n    });\n\n    this.messageHandlers.set(userId, subscription);\n    return subscription;\n  }\n\n  // Subscribe to read receipts\n  subscribeToReadReceipts(userId, callback) {\n    if (!this.stompClient || !this.connected) {\n      console.error('WebSocket not connected');\n      return null;\n    }\n\n    const destination = `/user/${userId}/queue/receipts`;\n    const subscription = this.stompClient.subscribe(destination, (message) => {\n      const receiptData = JSON.parse(message.body);\n      callback(receiptData);\n    });\n\n    this.receiptHandlers.set(userId, subscription);\n    return subscription;\n  }\n\n  // Subscribe to call notifications\n  subscribeToCallNotifications(userId, callback) {\n    if (!this.stompClient || !this.connected) {\n      console.error('WebSocket not connected');\n      return null;\n    }\n\n    const destination = `/user/${userId}/queue/calls`;\n    const subscription = this.stompClient.subscribe(destination, (message) => {\n      const callData = JSON.parse(message.body);\n      callback(callData);\n    });\n\n    this.callHandlers.set(userId, subscription);\n    return subscription;\n  }\n\n  // Subscribe to WebRTC signaling\n  subscribeToWebRTC(userId, callback) {\n    if (!this.stompClient || !this.connected) {\n      console.error('WebSocket not connected');\n      return null;\n    }\n\n    const destination = `/user/${userId}/queue/webrtc`;\n    const subscription = this.stompClient.subscribe(destination, (message) => {\n      const signalData = JSON.parse(message.body);\n      callback(signalData);\n    });\n\n    this.webRTCHandlers.set(userId, subscription);\n    return subscription;\n  }\n\n  // Send a chat message\n  sendMessage(message) {\n    if (!this.stompClient || !this.connected) {\n      console.error('WebSocket not connected');\n      return false;\n    }\n\n    this.stompClient.send('/app/chat.send', {}, JSON.stringify(message));\n    return true;\n  }\n\n  // Send read receipt for a message\n  sendReadReceipt(receipt) {\n    if (!this.stompClient || !this.connected) {\n      console.error('WebSocket not connected');\n      return false;\n    }\n\n    this.stompClient.send('/app/chat.read', {}, JSON.stringify(receipt));\n    return true;\n  }\n\n  // Send WebRTC offer signal\n  sendOffer(signal) {\n    if (!this.stompClient || !this.connected) {\n      console.error('WebSocket not connected');\n      return false;\n    }\n\n    this.stompClient.send('/app/call.offer', {}, JSON.stringify(signal));\n    return true;\n  }\n\n  // Send WebRTC answer signal\n  sendAnswer(signal) {\n    if (!this.stompClient || !this.connected) {\n      console.error('WebSocket not connected');\n      return false;\n    }\n\n    this.stompClient.send('/app/call.answer', {}, JSON.stringify(signal));\n    return true;\n  }\n\n  // Send ICE candidate\n  sendIceCandidate(signal) {\n    if (!this.stompClient || !this.connected) {\n      console.error('WebSocket not connected');\n      return false;\n    }\n\n    this.stompClient.send('/app/call.ice', {}, JSON.stringify(signal));\n    return true;\n  }\n\n  // Send hangup signal\n  sendHangup(signal) {\n    if (!this.stompClient || !this.connected) {\n      console.error('WebSocket not connected');\n      return false;\n    }\n\n    this.stompClient.send('/app/call.hangup', {}, JSON.stringify(signal));\n    return true;\n  }\n\n  // Unsubscribe from all\n  unsubscribeAll() {\n    this.messageHandlers.forEach((subscription) => {\n      subscription.unsubscribe();\n    });\n    this.messageHandlers.clear();\n\n    this.receiptHandlers.forEach((subscription) => {\n      subscription.unsubscribe();\n    });\n    this.receiptHandlers.clear();\n\n    this.callHandlers.forEach((subscription) => {\n      subscription.unsubscribe();\n    });\n    this.callHandlers.clear();\n\n    this.webRTCHandlers.forEach((subscription) => {\n      subscription.unsubscribe();\n    });\n    this.webRTCHandlers.clear();\n  }\n}\n\nexport default new WebSocketService();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}